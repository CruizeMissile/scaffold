
# Include guard
if(SCAF_UNITY_BUILDS_DONE)
  return()
endif()
set(SCAF_UNITY_BUILDS_DONE ON)

include(CMakeParseArguments)

function(sf_enable_unity_build target)
  # Parse arguments
  set(_options "")
  set(_single_args "COMPILE_UNITS;FILES_PER_UNIT;EXTENTION")
  set(_multi_args "SOURCE_LIST")
  cmake_parse_arguments(THIS "${_options}" "${_single_args}" "${_multi_args}" ${ARGN})

  get_target_property(target_type ${target} TYPE)
  if(${target_type} STREQUAL "INTERFACE_LIBRAY")
    message(FATAL_ERROR "Cannot enable unity builds for an interface library")
  endif()

  if(THIS_SORUCE_LIST)
    set(source_list "${THIS_SOURCE_LIST}")
  else()
    get_target_property(source_list ${target} SOURCES)
  endif()

  foreach(f ${source_list})
    message("${f}")
  endforeach(f ${source_list})
  message("")

  if(NOT source_list)
    message(FATAL_ERROR "Target: ${target} does not have any source files. You can add source files manualy with SOURCE_LIST")
  endif()

  # setting each source file to be excluded from all translation units but still tracked for changes
  # set_source_files_properties(${source_list} PROPERTIES HEADER_FILE_ONLY true)

  if(THIS_EXTENTION)
    set(extention ${THIS_EXTENTION})
  else()
    set(extention "cxx")
  endif()

  set(unity_build_dir ${CMAKE_CURRENT_BINARY_DIR}/unitybuild/${target})
  set(unity_build_file ${unity_build_dir}/unity_${target}.${extention})

  set(file_content "// Unity Build File Auto Generated By Cmake And Scaffold.\n\n")
  foreach(source_file ${source_list})
    if(${source_file} MATCHES "\.(c|cpp|cxx)$")
      set_source_files_properties(${source_file} PROPERTIES HEADER_FILE_ONLY true)
      set(file_content "${file_content}#include \"${source_file}\"\n")
    endif()
  endforeach(source_file ${source_list})

  file(WRITE ${unity_build_file} ${file_content})

  # adding the unity build to source file to the target
  target_sources(${target} PUBLIC ${unity_build_file})
  get_target_property(something ${target} SOURCES)
  foreach(f ${something})
    message("${f}")
  endforeach(f ${something})
  # sf_target_source_group(${target} DIRECTORY ${unity_build_dir} SOURCE_LIST ${unity_build_file})
endfunction()

# ────────────────────────────────────────────────────────────────────────────────

# function(_write_unity_build_file build_file build_file_content)
#   set(dirty false)
#   set(old_file_content "")

#   file(RELATIVE_PATH rel_path ${CMAKE_CURRENT_BINARY_DIR} ${build_file})
#   # message("${rel_path}")
#   if(NOT EXISTS ${rel_path} AND NOT EXISTS ${CMAKE_CURRENT_BINARY_DIR}/${rel_path})
#     set(dirty true)
#   else()
#     file(STRINGS ${build_file} old_file_content)
#     string(REPLACE ";" "" old_file_content "${old_file_content}")
#     string(REPLACE "\n" "" new_content "${${build_file_content}}")
#     string(COMPARE EQUAL "${old_file_content}" "${new_content}" equal_check)
#     if(NOT ${equal_check} EQUAL 1)
#       set(dirty true)
#     endif()
#   endif()

#   if(dirty MATCHES true)
#     message(STATUS "Write Unity build file:  ${build_file}")
#     message(STATUS "${build_file_content}")
#     # file(WRITE ${build_file} "${${build_file_content}}")
#   endif()

#   # Create a dummy copy of the unity file to trigger CMake reconfigure if it is deleted.
#   # set(unity_file_path "")
#   # set(unity_file_name "")
#   # get_filename_component(unity_file_path ${build_file} PATH)
#   # get_filename_component(unity_file_name ${build_file} NAME)
#   # configure_file(${build_file} ${unity_file_path}/CMakeFiles/${unity_file_name}.dummy)
# endfunction()

# function(sf_enable_unity_build target)
#   # Parse arguments
#   set(_options "")
#   set(_single_args "COMPILE_UNITS;FILES_PER_UNIT;EXTENTION")
#   set(_multi_args "SOURCE_LIST")
#   cmake_parse_arguments(THIS "${_options}" "${_single_args}" "${_multi_args}" ${ARGN})

#   # Checking to see if the target is not a interface library
#   get_target_property(target_type ${target} TYPE)
#   if(${target_type} STREQUAL "INTERFACE_LIBRAY")
#     message(FATAL_ERROR "Cannot enable unity builds for an interface library")
#   endif()

#   # get the list of source files. if there are no source files passed into this function then it will
#   # get the source files from the target
#   if(THIS_SORUCE_LIST)
#     set(source_list "${THIS_SOURCE_LIST}")
#   else()
#     get_target_property(source_list ${target} SOURCES)
#   endif()

#   # check to see if the source list is not empty
#   if(NOT source_list)
#     message(FATAL_ERROR "Target: ${target} does not have any source files. You can add source files manualy with SOURCE_LIST")
#   endif()

#   # setting each source file to be excluded from all translation units but still tracked for changes
#   set_source_files_properties(${source_list} PROPERTIES HEADER_FILE_ONLY true)

#   if(THIS_EXTENTION)
#     set(extention ${THIS_EXTENTION})
#   else()
#     set(extention "cxx")
#   endif()

#   # determine the number of build units that will be generated
#   #   - if there is nothing passed in then it will generate one unity complilation unit
#   #   - if COMPILE_UNITS is passed in then it divide the source files to fit into the number passed in
#   #      - ie if we have 100 source files and 'COMPILE_UNITS 4' then the souce files will be broken into 100 / 4 = 25 source files per comp unit
#   #   - if FILES_PER_UNIT is passed in then it will create a number of compile units all having  N number of files
#   #      - ie if we have 100 source files and 'FILES_PER_UNIT 10' then it will create 100 / 20 = 5 compile units
#   #   - NOTE: COMPILE_UNITS AND FILES_PER_UNIT cannot be defined together they must be one or the other or none at all

#   if(THIS_COMPILE_UNITS AND THIS_FILES_PER_UNIT)
#     message(FATAL_ERROR "Cannot define COMPILE_UNITS and FILES_PER_UNIT!")
#   endif()

#   # Note that limit is zero based
#   if(THIS_COMPILE_UNITS)
#     math(EXPR limit ${THIS_COMPILE_UNITS}-1)
#   # elseif(THIS_FILES_PER_UNIT)
#   #   math(EXPR limit ${THIS_FILES_PER_UNIT}-1)
#   else()
#     math(EXPR limit 0)
#   endif()

#   message("limit is ${limit}")

#   # creating a counter to count the number of source files up to the limit
#   set(counter ${limit})
#   set(file_number 0)
#   set(build_file "")
#   set(build_file_content "")
#   set(unity_build_files "")
#   set(depends "")

#   foreach(source_file ${source_list})
#     if (counter EQUAL limit)
#       set(depends "")

#       # write the unity build file
#       if(NOT ${build_file} STREQUAL "" AND NOT ${build_file_content} STREQUAL "")
#         # message("writing file ${build_file}")
#         _write_unity_build_file(${build_file} ${build_file_content})
#       endif()

#       set(unity_build_files ${unity_build_files} ${build_file})

#       # setup the information for the next build file
#       set(build_file ${CMAKE_CURRENT_BINARY_DIR}/unitybuild/${target}/${target}_${file_number}.${extention})
#       set(build_file_content "// Unity Build File Auto Generated By Cmake And Scaffold. Do Not modify!\n")
#       math(EXPR file_number ${file_number}+1)
#       set(counter 0)
#     else()
#       set(final_source_file "")
#       set(source_path "")
#       get_filename_component(source_path ${source_file} PATH)
#       if(source_path STREQUAL "" OR NOT EXISTS ${source_file})
#         set(final_source_file ${CMAKE_CURRENT_SOURCE_DIR}/${source_file})
#       else()
#         set(final_source_file ${source_file})
#       endif()

#       if(EXISTS ${final_source_file})
#         set(md5_hash "")
#         file(MD5 ${final_source_file} md5_hash)
#         set(build_file_content "${build_file_content}// md5: ${md5_hash}\n")
#       endif(EXISTS ${final_source_file})

#       set(build_file_content "${build_file_content}#include <${final_source_file}>\n")

#       # adding the source dependencies to the unity build
#       get_source_file_property(_file_depends ${source_file} OBJECT_DEPENDS)
#       if (_file_depends)
#         set(depends ${depends} ${_file_depends})
#         set_source_files_properties(${build_file} PROPERTIES OBJECT_DEPENDS ${depends})
#       endif()

#       # keep counting to limit
#       math(EXPR counter ${counter}+1)
#     endif()
#   endforeach(source_file ${source_list})
# endfunction()
